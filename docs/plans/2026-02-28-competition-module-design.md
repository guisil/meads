# Competition Module — Design Document

**Date:** 2026-02-28
**Branch:** `competition-module`
**Status:** Design complete, awaiting implementation

---

## Problem

The application currently has only the identity module. The next module in the roadmap is
`competition`, which manages events, competitions, participants, and categories. It also
provides the `AccessCodeValidator` implementation that activates the dormant access code
authentication path in the identity module.

---

## Requirements

### Domain Model

**Event → Competition hierarchy.** An Event is a real-world occasion (e.g., "Regional Mead
Festival 2026"). It contains one or more Competitions (e.g., "Home" and "Professional").
Events are containers with no lifecycle states of their own — state tracking is only on
competitions.

In practice, most events have one or two competitions, and the same judges, stewards, and
admins participate across all competitions within an event. However, different competitions
can have different participants, so participant assignment is per-competition (not per-event),
with a convenience mechanism to copy participants across competitions within an event.

### Competition Lifecycle

```
DRAFT → REGISTRATION_OPEN → REGISTRATION_CLOSED → JUDGING → DELIBERATION → RESULTS_PUBLISHED
```

- **DRAFT:** Setup phase. Categories, participants, and competition details can be modified.
- **REGISTRATION_OPEN:** Accepting entries (entry module, future).
- **REGISTRATION_CLOSED:** Entries locked. Participant changes still allowed (last-minute judge additions).
- **JUDGING:** Active judging. Participant list locked.
- **DELIBERATION:** Judges and admins discuss results. No scoring changes (future enforcement).
- **RESULTS_PUBLISHED:** Final. Competition is read-only.

Transitions are sequential and forward-only. No skipping, no reversal.

### Participant Roles

| Role | Description | Access Code? |
|---|---|---|
| ENTRANT | Submits entries to a competition | No |
| JUDGE | Evaluates entries, scores meads | Yes |
| STEWARD | Assists during judging sessions | Yes |
| COMPETITION_ADMIN | Manages a specific competition | No |

Rules:
- A user holds exactly one role per competition (enforced by unique constraint on `(competition_id, user_id)`).
- A user can hold different roles across different competitions.
- SYSTEM_ADMIN implicitly has all competition-level capabilities (checked at service layer).
- Competition-scoped authorization is enforced at the service layer, NOT via `@RolesAllowed`.

### Scoring System

MJP (Mead Judging Programme) only for now. Stored as an enum on Competition. Adding BJCP
later is a one-line enum addition.

### Categories

Categories follow the MJP catalog (M1–M4 with subcategories). Each competition gets the
full predefined catalog by default. Categories are seeded by Flyway migration.

**Future work (not designed here):** Merge subcategories (e.g., M2A + M2B → custom "M2AB"),
split subcategories (e.g., M2B → "M2B_dry" and "M2B_sweet"), and create entirely new
categories (e.g., "M5J — Meads made in January"). These operations will be designed in a
separate document when needed.

### Access Codes

- 8-character alphanumeric codes, uppercase-normalized.
- Stored on `CompetitionParticipant` records for JUDGE and STEWARD roles only.
- Generated by the service when a participant is added (or on demand).
- The competition module provides the `AccessCodeValidator` implementation that activates
  the identity module's dormant `AccessCodeAuthenticationProvider`.

---

## Design

### Package Layout

```
app.meads.competition                          ← Module root (public API)
├── package-info.java                          ← @ApplicationModule(allowedDependencies = {"identity"})
├── Event.java                                 ← JPA entity
├── Competition.java                           ← JPA entity
├── CompetitionParticipant.java                ← JPA entity
├── Category.java                              ← JPA entity (reference data)
├── CompetitionStatus.java                     ← Enum
├── CompetitionRole.java                       ← Enum
├── ScoringSystem.java                         ← Enum
├── EventService.java                          ← Application service
├── CompetitionService.java                    ← Application service
├── CompetitionStatusAdvancedEvent.java        ← Domain event record
└── internal/
    ├── EventRepository.java                   ← JpaRepository
    ├── CompetitionRepository.java             ← JpaRepository
    ├── CompetitionParticipantRepository.java  ← JpaRepository
    ├── CategoryRepository.java                ← JpaRepository
    ├── CompetitionAccessCodeValidator.java     ← Implements identity.AccessCodeValidator
    └── AccessCodeGenerator.java               ← 8-char alphanumeric code generation
```

### Module Dependency

```java
// competition/package-info.java
@org.springframework.modulith.ApplicationModule(
    allowedDependencies = {"identity"}
)
package app.meads.competition;
```

The competition module depends on the identity module's public API:
- `UserService.findById()` — validate user exists when adding participants
- `JwtMagicLinkService.generateLink()` — generate invitation links (future)
- `AccessCodeValidator` — interface to implement
- `User`, `Role`, `UserStatus` — referenced types

The identity module does NOT change its `allowedDependencies = {}`. The dependency is
one-directional: `competition → identity`.

---

### Entities

#### Event

**Location:** `app.meads.competition.Event` (public API)
**Table:** `events`

| Field | Type | Constraints | Notes |
|---|---|---|---|
| `id` | `UUID` | PK, assigned in constructor | |
| `name` | `String` | NOT NULL | |
| `startDate` | `LocalDate` | NOT NULL | Events span days |
| `endDate` | `LocalDate` | NOT NULL, >= startDate | |
| `location` | `String` | nullable | May not be known at creation |
| `createdAt` | `LocalDateTime` | NOT NULL, @PrePersist | |
| `updatedAt` | `LocalDateTime` | nullable, @PreUpdate | |

**Domain methods:**
- `updateDetails(String name, LocalDate startDate, LocalDate endDate, String location)` —
  validates `startDate <= endDate`, throws `IllegalArgumentException` if not

**JPA conventions:** Same as `User.java` — protected no-arg constructor, explicit `@Table`,
`@PrePersist`/`@PreUpdate`, manual getters, no setters, no Lombok.

No `List<Competition>` back-reference. Competitions reference Event by `eventId` UUID.

#### Competition

**Location:** `app.meads.competition.Competition` (public API)
**Table:** `competitions`

| Field | Type | Constraints | Notes |
|---|---|---|---|
| `id` | `UUID` | PK, assigned in constructor | |
| `eventId` | `UUID` | NOT NULL, FK → events | Plain UUID, no @ManyToOne |
| `name` | `String` | NOT NULL | |
| `status` | `CompetitionStatus` | NOT NULL, STRING | Defaults to DRAFT |
| `scoringSystem` | `ScoringSystem` | NOT NULL, STRING | |
| `createdAt` | `LocalDateTime` | NOT NULL, @PrePersist | |
| `updatedAt` | `LocalDateTime` | nullable, @PreUpdate | |

**Domain methods:**
- `advanceStatus()` — enforces sequential transition via switch; throws `IllegalStateException`
  at terminal state
- `updateDetails(String name, ScoringSystem scoringSystem)` — only allowed in DRAFT; throws
  `IllegalStateException` otherwise

**Constructor:** `Competition(UUID id, UUID eventId, String name, ScoringSystem scoringSystem)` —
sets `status = CompetitionStatus.DRAFT`.

No `@OneToMany` to participants. The service loads participants separately via the repository.
This is consistent with how `eventId` is a plain UUID (no `@ManyToOne`).

#### CompetitionParticipant

**Location:** `app.meads.competition.CompetitionParticipant` (public API)
**Table:** `competition_participants`

| Field | Type | Constraints | Notes |
|---|---|---|---|
| `id` | `UUID` | PK, assigned in constructor | |
| `competitionId` | `UUID` | NOT NULL, FK → competitions | Plain UUID |
| `userId` | `UUID` | NOT NULL, FK → users | Plain UUID |
| `role` | `CompetitionRole` | NOT NULL, STRING | |
| `accessCode` | `String` | nullable, length 8 | Only for JUDGE/STEWARD |
| `createdAt` | `LocalDateTime` | NOT NULL, @PrePersist | |

**Unique constraint:** `(competition_id, user_id)` — one role per user per competition.

**Domain methods:**
- `assignAccessCode(String code)` — validates role is JUDGE or STEWARD, validates code is
  exactly 8 chars, normalizes to uppercase. Throws `IllegalStateException` for wrong roles,
  `IllegalArgumentException` for invalid format.

No `updatedAt` — participant records are created and optionally get an access code assigned.
Role changes = remove and re-add.

#### Category

**Location:** `app.meads.competition.Category` (public API)
**Table:** `categories`

| Field | Type | Constraints | Notes |
|---|---|---|---|
| `id` | `UUID` | PK, assigned in constructor | |
| `code` | `String` | NOT NULL, unique | e.g., "M1A", "M2B" |
| `name` | `String` | NOT NULL | e.g., "Traditional Mead (Dry)" |
| `description` | `String` | NOT NULL | Style description |
| `scoringSystem` | `ScoringSystem` | NOT NULL, STRING | MJP for all current categories |

No `createdAt`/`updatedAt` — categories are reference data seeded by migration.
No domain methods — immutable lookup data.

---

### Enums

#### CompetitionStatus

```java
public enum CompetitionStatus {
    DRAFT,
    REGISTRATION_OPEN,
    REGISTRATION_CLOSED,
    JUDGING,
    DELIBERATION,
    RESULTS_PUBLISHED
}
```

#### CompetitionRole

```java
public enum CompetitionRole {
    JUDGE,
    STEWARD,
    ENTRANT,
    COMPETITION_ADMIN;

    public boolean requiresAccessCode() {
        return this == JUDGE || this == STEWARD;
    }
}
```

`requiresAccessCode()` is the single source of truth for which roles get access codes.
Used by both `CompetitionParticipant.assignAccessCode()` and `CompetitionAccessCodeValidator`.

#### ScoringSystem

```java
public enum ScoringSystem {
    MJP
}
```

Single value for now. Adding BJCP later is a one-line change.

---

### Services

#### EventService

**Location:** `app.meads.competition.EventService` (public API)

```java
@Service
@Transactional
@Validated
public class EventService {

    // Creates a new event. Validates startDate <= endDate.
    Event createEvent(@NotBlank String name,
                      @NotNull LocalDate startDate,
                      @NotNull LocalDate endDate,
                      String location);

    // Updates event details. Validates event exists, startDate <= endDate.
    Event updateEvent(@NotNull UUID eventId,
                      @NotBlank String name,
                      @NotNull LocalDate startDate,
                      @NotNull LocalDate endDate,
                      String location);

    Event findById(@NotNull UUID eventId);

    List<Event> findAll();

    // Deletes an event. Throws if competitions exist for this event.
    void deleteEvent(@NotNull UUID eventId);
}
```

#### CompetitionService

**Location:** `app.meads.competition.CompetitionService` (public API)

```java
@Service
@Transactional
@Validated
public class CompetitionService {

    // --- Competition CRUD ---

    // Creates a competition in DRAFT status.
    // Validates: event exists, requesting user is SYSTEM_ADMIN.
    Competition createCompetition(@NotNull UUID eventId,
                                  @NotBlank String name,
                                  @NotNull ScoringSystem scoringSystem,
                                  @NotNull UUID requestingUserId);

    // Updates name/scoring. Only allowed in DRAFT.
    // Validates: requesting user is SYSTEM_ADMIN or COMPETITION_ADMIN for this competition.
    Competition updateCompetition(@NotNull UUID competitionId,
                                  @NotBlank String name,
                                  @NotNull ScoringSystem scoringSystem,
                                  @NotNull UUID requestingUserId);

    // Advances to next status. Forward-only.
    // Validates: requesting user is SYSTEM_ADMIN or COMPETITION_ADMIN.
    // Publishes CompetitionStatusAdvancedEvent.
    Competition advanceStatus(@NotNull UUID competitionId,
                              @NotNull UUID requestingUserId);

    Competition findById(@NotNull UUID competitionId);

    List<Competition> findByEvent(@NotNull UUID eventId);

    // --- Participants ---

    // Adds a participant. Generates access code for JUDGE/STEWARD roles.
    // Validates: competition exists, user exists (via UserService.findById),
    //   user not already a participant, requesting user authorized.
    // Participant changes blocked after REGISTRATION_CLOSED (status >= JUDGING).
    CompetitionParticipant addParticipant(@NotNull UUID competitionId,
                                          @NotNull UUID userId,
                                          @NotNull CompetitionRole role,
                                          @NotNull UUID requestingUserId);

    // Removes a participant. Blocked after REGISTRATION_CLOSED.
    void removeParticipant(@NotNull UUID competitionId,
                           @NotNull UUID userId,
                           @NotNull UUID requestingUserId);

    List<CompetitionParticipant> findParticipants(@NotNull UUID competitionId);

    // --- Access codes ---

    // Regenerates the access code for a JUDGE/STEWARD participant.
    CompetitionParticipant regenerateAccessCode(@NotNull UUID competitionId,
                                                @NotNull UUID userId,
                                                @NotNull UUID requestingUserId);

    // --- Authorization helpers ---

    boolean isCompetitionAdmin(@NotNull UUID competitionId, @NotNull UUID userId);

    // --- Categories ---

    List<Category> findCategoriesByScoringSystem(@NotNull ScoringSystem scoringSystem);

    // --- Copy participants ---

    // Copies all participants from source to target competition.
    // Both must belong to the same event. Existing participants in target are skipped.
    // Access codes are carried over (same judge, same code across event competitions).
    // Target must be in DRAFT or REGISTRATION_OPEN status.
    int copyParticipants(@NotNull UUID sourceCompetitionId,
                         @NotNull UUID targetCompetitionId,
                         @NotNull UUID requestingUserId);
}
```

**Authorization pattern:** Every mutating method receives `requestingUserId` as a parameter.
The service checks:
1. Is the user a SYSTEM_ADMIN? (via `UserService.findById()` + `Role` check) → allowed.
2. Is the user a COMPETITION_ADMIN for this competition? (via participant query) → allowed.
3. Otherwise → throw `IllegalArgumentException`.

The view obtains `requestingUserId` from `AuthenticationContext`. The service never reads the
security context directly — keeps it testable without a security context.

---

### Domain Events

```java
// Published by CompetitionService.advanceStatus()
public record CompetitionStatusAdvancedEvent(
    UUID competitionId,
    CompetitionStatus previousStatus,
    CompetitionStatus newStatus
) {}
```

A single event type with old/new status replaces per-status events (e.g., `JudgingStartedEvent`).
Downstream listeners filter on `newStatus`:
- `entry` module → listens for `REGISTRATION_CLOSED` to stop accepting entries
- `judging` module → listens for `JUDGING` to open judging sessions
- `awards` module → listens for `RESULTS_PUBLISHED` to publish rankings

---

### AccessCodeValidator Implementation

**Location:** `app.meads.competition.internal.CompetitionAccessCodeValidator`

```java
@Component
class CompetitionAccessCodeValidator implements AccessCodeValidator {

    private final CompetitionParticipantRepository participantRepository;
    private final UserService userService;

    @Override
    public boolean validate(String email, String code) {
        // 1. Find participants with this access code (expected: 0 or 1 per competition)
        List<CompetitionParticipant> matches =
            participantRepository.findByAccessCode(code.toUpperCase());

        // 2. Check if any match belongs to the given email
        return matches.stream()
            .filter(p -> p.getRole().requiresAccessCode())
            .anyMatch(p -> {
                User user = userService.findById(p.getUserId());
                return user.getEmail().equalsIgnoreCase(email);
            });
    }
}
```

This implementation:
- Lives in `internal/` (module-private, discovered by Spring via the `AccessCodeValidator` interface)
- Uses `UserService.findById()` to resolve email from `userId` (respects module boundary)
- Does NOT join across module tables in SQL — goes through the service API
- Expected O(1) in practice: access codes are unique within a competition, and typically unique globally

Once this bean exists, `SecurityConfig`'s `Optional<AccessCodeValidator>` becomes non-empty
and `AccessCodeAuthenticationProvider` is automatically wired into the filter chain.

---

### Access Code Login — Auth Flow Fix

**Problem:** The existing `LoginForm` credentials tab always submits a `UsernamePasswordAuthenticationToken`.
`AccessCodeAuthenticationProvider.supports()` only accepts `AccessCodeAuthenticationToken`, so it never
activates through the standard form login.

**Solution:** Modify `AccessCodeAuthenticationProvider` to also support `UsernamePasswordAuthenticationToken`.

```
Current flow:
  LoginForm POST → UsernamePasswordAuthenticationToken
    → DaoAuthenticationProvider: tries password match → fails (user has no password) → BadCredentialsException
    → AccessCodeAuthenticationProvider: supports(UPAT) = false → skipped
    → Authentication fails

Fixed flow:
  LoginForm POST → UsernamePasswordAuthenticationToken
    → DaoAuthenticationProvider: tries password match → fails → BadCredentialsException
    → AccessCodeAuthenticationProvider: supports(UPAT) = true → tries access code validation
      → accessCodeValidator.validate(email, credentials) → true → authenticated!
```

Changes to identity module:

1. **`AccessCodeAuthenticationProvider.supports()`** — return `true` for both
   `AccessCodeAuthenticationToken` and `UsernamePasswordAuthenticationToken`.

2. **`AccessCodeAuthenticationProvider.authenticate()`** — handle both token types:
   - For `AccessCodeAuthenticationToken`: extract email/code as before.
   - For `UsernamePasswordAuthenticationToken`: extract username as email, credentials as code.
   - Call `accessCodeValidator.validate(email, code)`.
   - If valid: load user details, return authenticated token.
   - If invalid: return `null` (let Spring Security report the failure).

3. **No UI changes.** The existing "Code / Password" field label already communicates that
   both are accepted. Spring Security's `ProviderManager` tries `DaoAuthenticationProvider`
   first (password), then falls back to `AccessCodeAuthenticationProvider` (access code).

**Edge case — users with passwords:** For SYSTEM_ADMIN users who have passwords,
`DaoAuthenticationProvider` succeeds on the first try. `AccessCodeAuthenticationProvider`
is never reached. This is correct behavior.

**Edge case — `DatabaseUserDetailsService` returns empty string for null password hash:**
When a user has no password (judges, stewards), `DatabaseUserDetailsService` returns `""`
as the password hash. BCrypt's `matches()` will return `false` for any input compared against
an empty string, so `DaoAuthenticationProvider` throws `BadCredentialsException`. The
`AccessCodeAuthenticationProvider` then gets a chance to try the credentials as an access code.
This is the correct fallback behavior.

---

### Access Code Generator

**Location:** `app.meads.competition.internal.AccessCodeGenerator`

```java
class AccessCodeGenerator {

    private static final String CHARS = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
    private static final int CODE_LENGTH = 8;
    private static final SecureRandom RANDOM = new SecureRandom();

    static String generate() {
        var sb = new StringBuilder(CODE_LENGTH);
        for (int i = 0; i < CODE_LENGTH; i++) {
            sb.append(CHARS.charAt(RANDOM.nextInt(CHARS.length())));
        }
        return sb.toString();
    }
}
```

Excludes ambiguous characters (0/O, 1/I/L) for readability when printed on badges or
communicated verbally.

---

### Repositories

All repositories live in `internal/`, are `public` (needed for constructor injection
from services in the module root), and extend `JpaRepository<Entity, UUID>`.

| Repository | Key Query Methods |
|---|---|
| `EventRepository` | (standard CRUD only) |
| `CompetitionRepository` | `List<Competition> findByEventId(UUID)` |
| `CompetitionParticipantRepository` | `findByCompetitionId(UUID)`, `findByCompetitionIdAndUserId(UUID, UUID)`, `existsByCompetitionIdAndUserId(UUID, UUID)`, `findByAccessCode(String)` |
| `CategoryRepository` | `List<Category> findByScoringSystem(ScoringSystem)` |

---

## Database Migrations

Current highest: V4. Competition module starts at V5.

### V5 — Create events table

```sql
CREATE TABLE events (
    id         UUID         PRIMARY KEY,
    name       VARCHAR(255) NOT NULL,
    start_date DATE         NOT NULL,
    end_date   DATE         NOT NULL,
    location   VARCHAR(500),
    created_at TIMESTAMP    NOT NULL,
    updated_at TIMESTAMP
);
```

### V6 — Create competitions table

```sql
CREATE TABLE competitions (
    id             UUID         PRIMARY KEY,
    event_id       UUID         NOT NULL REFERENCES events(id),
    name           VARCHAR(255) NOT NULL,
    status         VARCHAR(50)  NOT NULL,
    scoring_system VARCHAR(50)  NOT NULL,
    created_at     TIMESTAMP    NOT NULL,
    updated_at     TIMESTAMP
);

CREATE INDEX idx_competitions_event_id ON competitions(event_id);
```

### V7 — Create competition_participants table

```sql
CREATE TABLE competition_participants (
    id             UUID        PRIMARY KEY,
    competition_id UUID        NOT NULL REFERENCES competitions(id),
    user_id        UUID        NOT NULL REFERENCES users(id),
    role           VARCHAR(50) NOT NULL,
    access_code    CHAR(8),
    created_at     TIMESTAMP   NOT NULL,
    CONSTRAINT uq_competition_participant UNIQUE (competition_id, user_id)
);

CREATE INDEX idx_participants_competition_id ON competition_participants(competition_id);
CREATE INDEX idx_participants_access_code ON competition_participants(access_code)
    WHERE access_code IS NOT NULL;
```

The partial index on `access_code` supports fast lookups in `CompetitionAccessCodeValidator`
without indexing null rows (ENTRANTs and COMPETITION_ADMINs).

### V8 — Create categories table and seed MJP catalog

```sql
CREATE TABLE categories (
    id             UUID         PRIMARY KEY,
    code           VARCHAR(50)  NOT NULL UNIQUE,
    name           VARCHAR(255) NOT NULL,
    description    TEXT         NOT NULL,
    scoring_system VARCHAR(50)  NOT NULL
);

-- MJP Category Catalog
-- Source: Mead Judging Programme (meadjudgingprogramme.com)

-- M1: Traditional Mead
INSERT INTO categories (id, code, name, description, scoring_system) VALUES
    (gen_random_uuid(), 'M1A', 'Traditional Mead (Dry)', 'Traditional mead, dry style — honey, water, and yeast only', 'MJP'),
    (gen_random_uuid(), 'M1B', 'Traditional Mead (Medium)', 'Traditional mead, semi-sweet/semi-dry style', 'MJP'),
    (gen_random_uuid(), 'M1C', 'Traditional Mead (Sweet)', 'Traditional mead, sweet style', 'MJP');

-- M2: Fruit Meads (Melomels)
INSERT INTO categories (id, code, name, description, scoring_system) VALUES
    (gen_random_uuid(), 'M2A', 'Pome Fruit Melomel', 'Mead with pome fruits — apples, pears, quince', 'MJP'),
    (gen_random_uuid(), 'M2B', 'Pyment', 'Mead with grapes', 'MJP'),
    (gen_random_uuid(), 'M2C', 'Berry Melomel', 'Mead with berry fruits', 'MJP'),
    (gen_random_uuid(), 'M2D', 'Stone Fruit Melomel', 'Mead with stone fruits', 'MJP'),
    (gen_random_uuid(), 'M2E', 'Other Fruit Melomel', 'Mead with other fruits or fruit combinations', 'MJP');

-- M3: Spiced Meads (Metheglins)
INSERT INTO categories (id, code, name, description, scoring_system) VALUES
    (gen_random_uuid(), 'M3A', 'Fruit and Spice Mead', 'Mead with one or more fruits and one or more spices', 'MJP'),
    (gen_random_uuid(), 'M3B', 'Metheglin', 'Mead with herbs, spices, or vegetables', 'MJP'),
    (gen_random_uuid(), 'M3C', 'Other Metheglin', 'Mead with coffee, chocolate, chili, nuts, or seeds', 'MJP');

-- M4: Specialty Meads
INSERT INTO categories (id, code, name, description, scoring_system) VALUES
    (gen_random_uuid(), 'M4A', 'Braggot', 'Mead with malt and/or hops — beer-style honey beverage', 'MJP'),
    (gen_random_uuid(), 'M4C', 'Experimental Mead', 'Mead with novel ingredients or processes', 'MJP'),
    (gen_random_uuid(), 'M4E', 'Bochet', 'Mead made with caramelized honey', 'MJP'),
    (gen_random_uuid(), 'M4S', 'Session Mead', 'Mead under 7.5% ABV', 'MJP');
```

**Note:** M1V (Varietal), M4D (Distillates), M4G (Sparkling), M4P (Polish Dessert), and
M4Z (Alcohol-Free) are excluded from the initial seed as they are marked "PRO competition
restricted" in the MJP guidelines. They can be added via a future migration when needed.

---

## Views (Future — Not Designed in Detail)

Views will follow the `UserListView` pattern: `@Route(layout = MainLayout.class)`,
`@RolesAllowed`, `transient AuthenticationContext`, Dialog-based forms, Grid for lists.

### Planned Views

| View | Location | Route | Access |
|---|---|---|---|
| `EventListView` | `internal/` | `/events` | SYSTEM_ADMIN |
| `CompetitionListView` | `internal/` | `/events/{eventId}/competitions` | SYSTEM_ADMIN |
| `CompetitionDetailView` | `internal/` | `/competitions/{id}` | SYSTEM_ADMIN or COMPETITION_ADMIN (service-level check) |

`MainLayout` will need a new "Events" nav button, visible to SYSTEM_ADMIN users.

Views are out of scope for this design document. They will be designed as part of the
implementation phase, following the existing view patterns.

---

## Implementation Sequence

Each item is a full RED-GREEN-REFACTOR cycle. Work in this order per CLAUDE.md's
"Sequencing for Multi-Layer Features" rule.

### Phase 1 — Module Skeleton and Event Entity

1. Create `package-info.java` with `allowedDependencies = {"identity"}`.
2. Run `ModulithStructureTest` — must pass with new module.
3. Unit test: `EventTest` — `updateDetails()` validates date ordering.
4. Repository test: `EventRepositoryTest` — save/find. Drives V5 migration.
5. Unit test: `EventServiceTest` — `createEvent`, `deleteEvent` with mocked repository.
6. Module integration test: `CompetitionModuleTest` — context boots.

### Phase 2 — Competition Entity and Lifecycle

7. Unit test: `CompetitionTest` — `advanceStatus()` sequential transitions, terminal state.
8. Unit test: `CompetitionTest` — `updateDetails()` blocked after DRAFT.
9. Repository test: `CompetitionRepositoryTest` — save/find, eventId FK. Drives V6 migration.
10. Unit test: `CompetitionServiceTest` — `createCompetition` with authorization check.
11. Unit test: `CompetitionServiceTest` — `advanceStatus` publishes event.

### Phase 3 — Participants and Access Codes

12. Unit test: `CompetitionParticipantTest` — `assignAccessCode()` role and format validation.
13. Repository test: `CompetitionParticipantRepositoryTest` — save/find/unique constraint. Drives V7.
14. Unit test: `CompetitionServiceTest` — `addParticipant` validates user exists, generates code.
15. Unit test: `CompetitionServiceTest` — `removeParticipant` blocked after REGISTRATION_CLOSED.
16. Unit test: `CompetitionServiceTest` — `copyParticipants` same-event check, skips existing.

### Phase 4 — AccessCodeValidator

17. Integration test: `CompetitionAccessCodeValidatorTest` — validates `(email, code)` pairs
    against real DB. Tests the full cross-module integration.

### Phase 5 — Auth Flow Fix (Identity Module Change)

18. Unit test: Update `AccessCodeAuthenticationProviderTest` — `supports(UsernamePasswordAuthenticationToken)`
    returns true.
19. Unit test: `AccessCodeAuthenticationProviderTest` — authenticates with `UsernamePasswordAuthenticationToken`
    when access code is valid.

### Phase 6 — Categories

20. Repository test: `CategoryRepositoryTest` — find by scoring system. Drives V8 migration.
21. Unit test: `CompetitionServiceTest` — `findCategoriesByScoringSystem`.

### Phase 7 — Views

22. UI test: `EventListView` — CRUD for events.
23. UI test: `CompetitionListView` — list competitions per event, create competition.
24. UI test: `CompetitionDetailView` — manage participants, advance status, copy participants.
25. Add "Events" nav link to `MainLayout` (fast cycle — existing `MainLayoutTest` covers it).

---

## Out of Scope

- Category merge/split/custom operations (future design doc when needed)
- Competition-specific entry registration (entry module)
- Judging sessions, scoresheets, judge assignments (judging module)
- Score aggregation, medals, rankings (awards module)
- Email delivery of magic links and access codes (currently logged to console)
- BJCP scoring system support
- TOTP second factor for admin login
- JWT revocation list
- M1V, M4D, M4G, M4P, M4Z PRO-restricted categories (add via future migration)
- Detailed view UX design (views follow existing patterns; designed during implementation)

---

## Open Questions (Resolved During Design)

| Question | Resolution |
|---|---|
| Should Event have lifecycle states? | No — Event is a container. Only Competition has states. |
| Where are participants assigned? | Per competition, not per event. Copy mechanism for convenience. |
| Should CompetitionParticipant be in `internal/`? | No — public API, consistent with `User.java`. Future modules need it. |
| How does access code login work through `LoginForm`? | Modify `AccessCodeAuthenticationProvider` to also support `UsernamePasswordAuthenticationToken`. DaoAuth fails first, then access code is tried as fallback. No UI changes. |
| Should access codes be copied during `copyParticipants`? | Yes — same judge, same code across competitions within an event. |
| MJP categories — include PRO-restricted? | No — seed only the universally applicable categories. PRO categories added by future migration. |
| Single event type or per-status events? | Single `CompetitionStatusAdvancedEvent` with old/new status. Listeners filter by `newStatus`. |
| Should `Competition` have `@OneToMany` to participants? | No — plain UUID references, consistent with `eventId` pattern. Service loads separately. |
